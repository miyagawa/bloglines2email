#!/usr/local/bin/perl -w
use strict;
use DateTime;
use DateTime::Format::Mail;
use Encode;
use FindBin;
use File::Spec;
use Getopt::Long;
use MIME::Lite;
use Template;
use WebService::Bloglines;
use YAML;

our $VERSION = '0.01';

GetOptions(\our %opt, "test", "verbose");

my $conf = File::Spec->catfile($FindBin::Bin, "bloglines2email.conf");
my $cfg  = YAML::LoadFile($conf);

my $bws = WebService::Bloglines->new(
    username => $cfg->{username},
    password => $cfg->{password},
);

my $mark_read = $opt{test} ? 0 : 1;
my @updates = $bws->getitems(0, $mark_read);
debug(scalar(@updates) . " feeds updated.");
for my $update (@updates) {
    send_email($cfg, $update);
}

sub debug {
    my $msg = "@_";
    chomp($msg);
    print STDERR encode('utf-8', "$msg\n") if $opt{verbose};
}

sub send_email {
    my($cfg, $update) = @_;
    my $feed  = $update->feed;
    my @items = $update->items;
    if ($cfg->{'group-items'}) {
        send_email_feed($cfg, $feed, \@items);
    }
    else {
        for my $item (@items) {
            send_email_item($cfg, $feed, $item);
        }
    }
}

sub send_email_feed {
    my($cfg, $feed, $items) = @_;
    my $subject = $feed->{title} || '(no-title)';
    my $body = join '<hr />', map format_body($feed, $_, $cfg), @$items;
    do_send_mail($cfg, $feed, $subject, $body);
}

sub send_email_item {
    my($cfg, $feed, $item) = @_;
    my $subject = $item->{title} || '(no-title)';
    my $body    = format_body($feed, $item, $cfg);
    do_send_email($cfg, $feed, $subject, $body);
}

sub do_send_mail {
    my($cfg, $feed, $subject, $body) = @_;
    debug("Sending $subject to $cfg->{mailto}");
    my $feed_title = $feed->{title};
       $feed_title =~ tr/,//d;
    my $msg = MIME::Lite->new(
        Date => get_rfc2822_date($cfg),
        From => encode('MIME-Header', qq("$feed_title" <$cfg->{mailfrom}>)),
        To   => $cfg->{mailto},
        Subject => encode('MIME-Header', $subject),
        Type => 'multipart/related',
    );
    $msg->attach(
        Type => 'text/html; charset=utf-8',
        Data => encode("utf-8", $body),
    );
    $msg->send("smtp", "localhost", Timeout => 60)
}

sub get_rfc2822_date {
    my $cfg = shift;
    my $dt  = @_
        ? DateTime::Format::Mail->parse_datetime($_[0])
        : DateTime->now;
    my $tz = $cfg->{'date-timezone'} || 'local';
    $dt->set_time_zone($tz);
    DateTime::Format::Mail->format_datetime($dt);
}

sub format_body {
    my($feed, $item, $cfg) = @_;
    my $template = get_template();
    my $tt = Template->new;
    $tt->process(\$template, {
        feed => $feed,
        item => $item,
        cfg  => $cfg,
        get_rfc2822_date => sub { get_rfc2822_date($cfg, @_) },
    }, \my $out);
    $out;
}

sub get_template {
    return <<'HTML';
<div>
[% var = 'group-items'; IF cfg.$var %]<h2 style="font-size: 1.2em; margin: 0">[% item.title | html %]</h2>[% END %]
[% IF feed.image %]<div style="float:right"><a href="[% feed.image.link %]"><img style="border:0" src="[% feed.image.url | html %]" alt="[% feed.image.title | html %]" /></a></div>[% END %]
<div>Link: <a href="[% item.link | html %]">[% item.link | html %]</a><br />
[% IF item.dc.creator %]by [% item.dc.creator | html %][% END %][% IF item.dc.subject %] on [% item.dc.subject %][% END %]</div>
<div style="clear:both"></div>
<div[% UNLESS item.description.match('(?i)^<p[ >]') %] style="padding: 1em 0"[% END %]>[% item.description %]</div>
<div style="font-size:0.8em">[% IF item.pubDate %]Posted on [% get_rfc2822_date(item.pubDate) %][% END %] | <a href="[% item.link | html %]">permalink</a> | <a href="[% feed.link | html %]">[% feed.title | html %]</a></div>
</div>
HTML
}

=head1 NAME

bloglines2email - Send Bloglines unread items as HTML mail

=head1 AUTHOR

Tatsuhiko Miyagawa E<lt>miyagawa@bulknews.netE<gt>

This script is free software and licensed under the same terms as Perl
(Artistic/GPL).

=cut
